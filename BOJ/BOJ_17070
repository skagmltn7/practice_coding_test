"""
output: 이동시키는 방법의 개수
1. 아이디어
    - 이동
        - ㅡ일 경우 : ㅡ,대각선
        - ㅣ일 경우 : ㅣ,대각선
        - 대각선일 경우: ㅡ,ㅣ, 대각선
    - visit 경우의 수

"""
import sys; input = sys.stdin.readline
from collections import deque

direction = [(0,0),(1,0),(1,1)]
mode = [[0,2], [1,2], [0,1,2]]

N = int(input())
board = [[0 for _ in range(N+1)]for _ in range(N+1)]

def dchk(y,x):
    if (1 <= x +1 <= N and board[y][x+1]!=1)and (1 <= y +1 <= N and board[y+1][x]!=1): return True
    return False

for i in range(1,N+1):
    board[i][1:] = list(map(int,input().split()))

def bfs():
    answer = 0
    visited = [[[False for _ in range(N+1)]for _ in range(N+1)] for _ in range(3)]
    queue = deque()
    queue.append((1,1,1,2,0))
    visited[1][2][0] = True

    while queue:
        cury1, curx1, cury2, curx2, curd = queue.popleft()
        if (cury1 == N and curx1 == N) or (cury2==N and curx2 ==N):
            answer += 1
            continue
        for nxtd in mode[curd]:
            dy, dx = direction[nxtd]
            ny, nx = cury2 + dy, curx2 + dx
            if 1 <= ny <= N and 1 <= nx <= N:
                if not visited[nxtd][ny][nx] and board[ny][nx] != 1:
                    if nxtd == 2 and not dchk(cury2,curx2): continue
                    visited[nxtd][ny][nx] = True
                    queue.append((cury2,curx2,ny,nx,nxtd))
    return answer

print(bfs())
